class VotingMajo:    """    The winner is the fact with the majority, no loop.    """    def __init__(self, G):        self.init_trust = 1.0                self.G = G        self.G.reset_graph([self.init_trust for i in range(len(self.G.mat_fs[0]))])            def trust_sources(self):        """        Compute the trust for the sources        """        tmp_trust_s = [0 for i in self.G.trust_s]        for i in range(len(self.G.trust_s)):            tmp_trust_s[i] = sum(self.G.sf[i]*self.G.trust_f)        self.G.trust_s = tmp_trust_s            def trust_fact(self):        """        Compute the trust for the facts        """        tmp_trust_f = [0 for i in self.G.trust_f]        for i in range(len(self.G.trust_f)):            tmp_trust_f[i] = sum(self.G.mat_fs[i]*self.G.trust_s)        self.G.trust_f = tmp_trust_f    def compute_theoritical_trust(self):        s = [0 for n in self.G.sf]        tmp = []        for i in range(len(self.G.obj.of)):            best = self.G.obj.get_best_fact(i)            for n in self.G.obj.of[i].prec:                if n in best:                    tmp.append(1)                else:                    tmp.append(0)        for inds,l in enumerate(self.G.sf):            for i in range(len(tmp)):                if tmp[i] == 1 and l[i] == 1:                    s[inds] += 1        # self.G.trust_s = [round(s[i]/len(self.G.mat_of),3) for i in range(len(s))]        self.G.trust_s = [s[i]/len(self.G.mat_of) for i in range(len(s))]                def run(self):        print(self.G.str_trust())        self.G.iteration += 1                self.trust_fact()        self.G.obj.update_trust(self.G.trust_f)                self.compute_theoritical_trust()                    print(self.G.str_trust())                def run_noprint(self):        self.G.iteration += 1                self.trust_fact()        self.G.obj.update_trust(self.G.trust_f)                       self.compute_theoritical_trust()